[toc]

---

## 各排序算法时间复杂度分析总结
总结如下：

排序算法 | 时间复杂度分析
---|---
快速排序（quickSort） | 1.O(nlog2n) 2.不稳定
选择排序（selectSort） | 1.O(n^2) 2.不稳定
插入排序（insertSort） | 1.O(n^2) 2.稳定
冒泡排序（bubbleSort） | 1.O(n^2) 2.稳定

### 快速排序分析
```
1.在最快及平均情况下，时间复杂度为O(nlog2n)。
最坏情况就是每次挑中的中间值不是最大就是最小，其时间复杂度为O(n^2)。
说明：
平均的时间复杂度记住就好了。
但是最坏的情况确实是可以算出来的，
假设每次选的基准值都是最大的，那么对于end的操作，一开始就找到比index值小的数，
而对于start的操作，则要一直循环n-1次才能让循环停下来。

交换一次index值后，选择的基准值又是最大的，那么start的操作就是n-2次......

以此类推，直到排序完成，1 + 2 + ... + n - 1，所以数量级为n^2，这意味着，数据如果是倒序的，使用上面的实现，那么此时的时间复杂度就为O(n^2).

2.快速排序法不是稳定排序法。
可以考虑，当基准值index与arr[start]值进行交换时，假设arr[start - 1] == index时，那么可以看到，其确实是不稳定的。

3.快速排序法是平均运行时间最快的排序法。
```
### 选择排序分析
```
1.时间复杂度为：O(n^2)
比较的次数(n-1) + (n-2) + ... + 2 + 1=(n-1 + 1) * (n-1)/2 = n*(n-1)/2 = n^2/2 - n/2

2.数据排列顺序是有可能被改变的，考虑1,7,7,2的情况，第二个7会与2交换位置，所以其是不稳定的排序算法。
```
### 插入排序分析
```
1.时间复杂度为：O(n^2)

2.插入排序是稳定排序法
```
### 冒泡排序分析
```
1.可以看到，将比较次数相加起来（等差数列），其时间复杂度为O(n^2)

2.由于冒泡排序为相邻两者相互比较对调，并不会更改其原本排序的顺序，所以是稳定排序法
```

### 各排序算法记忆分析
首先快速排序算法，会就会，不会就不会了，一般不会说出现跟其它排序算法混在一起的问题。
但相比之下的选择排序、插入排序和冒泡排序，着实很多时候会出现混乱，事实如果我们要做一个排序的操作，一般来讲这三种算法之一，可能你都很轻易的就能想到，但你不会去关注它到底是属于哪种排序算法，感觉起来，好像确实比较相像，不过这里还是对比分析一下，主要是为了方便记忆而已，事实如果不是为了特定目的的话，可以不用去记的。

> 我个人的话，确实是因为没有掌握算法的真谛或者对算法没有感觉，即使在某个时间点对这几类算法记忆很清晰，但一段时间后，总能忘记得差不多。

| 算法                   | 记忆举例                                                     | 时间复杂度 | 是否稳定 |
| ---------------------- | ------------------------------------------------------------ | ---------- | -------- |
| 快速排序（quickSort）  | /                                                            | O(nlog2n)  | 不稳定   |
| 选择排序（selectSort） | 对于`8, -2, 3, 9, 0, 1, 7, 6}`，<br>1.方法来看，它是尝试从索引为[0]位置开始，依次将自己跟后面的进行比较，一旦发现比它自己小的，就将这个数字拿到该位置，每次都从无序串中“选择”一个最小的加入到前面的有序串，这也是其名称由来；<br>2.过程来看，索引[0]数字升序-->索引[0,1]数字升序-->索引[0,1]数字升序-->直到最后整体升序；<br>3.稳定性来看，从上面过程分析，考虑1,7,7,2的情况，第二个7会与2交换位置，所以其是不稳定的排序算法； | O(n^2)     | 不稳定   |
| 插入排序（insertSort） | 对于`{8, -2, 3, 9, 0, 1, 7, 6}`，<br>1.方法来看，它是从索引为[1]位置开始，它假设在当前索引位置前的所有数字都是有序的，然后考虑把当前索引的数字放到前面的某个位置，使得当前索引位置的数字和其前面数字都整体有序，这也是其名称由来；<br>2.过程来看，索引[0]数字串有序，索引[1]数字准备加入到其中-->索引[0,1]数字串有序，索引[2]数字准备加入到其中->最后整体升序；<br>3.稳定性来看，从上面过程分析，其为相邻两者相互比较对调，并不会更改其原本排序的顺序，所以是稳定排序法； | O(n^2)     | 稳定     |
| 冒泡排序（bubbleSort） | 对于`{8, -2, 3, 9, 0, 1, 7, 6}`，<br>1.方法来看，它每次循环都是从索引为[0]位置开始，相邻两个数字之间进行比较，如果以升序方式来交换两个数字位置，使得每次循环都会把当前无序串的最大数字移到后面，就是要把它“冒”出去，这也是其名称由来；<br>2.过程来看，假设长度为n，索引[0, ..., n-2]无序，索引[n-1]有序-->索引[0, ..., n-3]无序，索引[n-2,n-1]有序-->最后整体升序；<br>3.稳定性来看，从上面过程分析，其为相邻两者相互比较对调，并不会更改其原本排序的顺序，所以是稳定排序法； | O(n^2)     | 稳定     |

